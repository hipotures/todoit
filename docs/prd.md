# Implementacja TODOIT MCP

Zaimplementuj system TODOIT MCP - uniwersalny system zarzƒÖdzania listami TODO z integracjƒÖ MCP dla Claude Code.

## Stack technologiczny
- Python 3.12+
- SQLite (embedded)
- SQLAlchemy 2.0 + Pydantic
- MCP SDK dla Claude Code
- Click + Rich dla CLI

## Architektura
```
Claude Code <--MCP--> TodoMCPServer <--API--> TodoManager <--ORM--> SQLite
                                                    ^
                                                    |
                                               Rich CLI
```

## Struktura projektu
```
todoit-mcp/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ manager.py      # TodoManager z 37 funkcjami
‚îÇ   ‚îú‚îÄ‚îÄ models.py       # Pydantic models
‚îÇ   ‚îî‚îÄ‚îÄ database.py     # SQLAlchemy layer
‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îú‚îÄ‚îÄ mcp_server.py   # MCP wrapper
‚îÇ   ‚îî‚îÄ‚îÄ cli.py          # Rich CLI
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îî‚îÄ‚îÄ init_db.sql     # Schema (4 tabele)
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ pyproject.toml
```

## Schemat bazy
- **todo_lists**: list_key (unique), title, type, metadata (JSON)
- **todo_items**: item_key, content, status, completion_states (JSON), metadata (JSON)
- **list_relations**: dla powiƒÖza≈Ñ (project_id, tag, sprint_id)
- **todo_history**: audit log

## Kluczowe funkcje (Etap 1 - minimum 10)
1. create_list (pusta, -n count, -d folder)
2. get_list (po ID lub key)
3. delete_list (z walidacjƒÖ powiƒÖza≈Ñ)
4. list_all
5. add_item
6. update_item_status (z multi-state)
7. get_next_pending
8. get_progress
9. import_from_markdown (multi-column ‚Üí powiƒÖzane listy)
10. export_to_markdown (format [x])

## Tworzenie list - 3 tryby
```python
# Pusta
create_list("projekt_x")

# Z N elementami
create_list("tasks", template="Task nr", count=10)
# ‚Üí "Task nr 1", "Task nr 2", ..., "Task nr 10"

# Z folderu
create_list("deploy", template="Deploy ", directory="/configs/")
# ‚Üí zadanie dla ka≈ºdego pliku
```

## Import multi-column
```
[x] [ ] Task 1    ‚Üí tworzy 2 powiƒÖzane listy
[x] [x] Task 2    ‚Üí lista2[N] wymaga lista1[N] = completed
```

## Multi-state completion
```python
# Dla z≈Ço≈ºonych zada≈Ñ z wieloma etapami:
completion_states = {
    "designed": True,
    "implemented": True,
    "tested": False,
    "deployed": False
}
```

## CLI z Rich
```bash
# Tworzenie list
todoit list create projekt_x                          # pusta
todoit list create tasks -n 10 -t "Task nr"          # 10 element√≥w
todoit list create deploy -d /configs/ -t "Deploy "  # z folderu

# Operacje
todoit list show 42              # przez ID
todoit list show projekt_x       # przez key
todoit list delete lista1        # z walidacjƒÖ powiƒÖza≈Ñ
todoit item check tasks task_1   # oznacz jako done

# Import/Export
todoit io import tasks.md        # multi-column ‚Üí wiele list
todoit io export projekt_x out.md # format [x]
```

## MCP Tools
- todo_create_list
- todo_add_item  
- todo_check_item (z multi-state)
- todo_get_next
- todo_get_progress

## Etapy implementacji

### Etap 1: Minimum (10 funkcji)
- create_list, get_list, delete_list, list_all
- add_item, update_item_status, get_next_pending, get_progress
- import_from_markdown, export_to_markdown

### Etap 2: Podstawowe rozszerzenie (8 funkcji)
- update_list, update_item, delete_item, append_items
- get_items_by_status, bulk_check
- create_list_relation, get_lists_by_relation

### Etap 3: Zaawansowane (10 funkcji)
- update_item_states, reorder_items, extend_list, insert_item
- search_items, bulk_update
- set_item_dependency, get_dependencies
- get_timeline, get_blocked_items

### Etap 4: Pe≈Çny zestaw (9 funkcji)
- clone_list, merge_lists
- reset_item, archive_list, get_item_metadata, add_note
- handle_failed, retry_failed_items, get_stale_items

## Wa≈ºne
1. Programmatic API (TodoManager) jako core
2. MCP i CLI to tylko thin wrappers
3. Ka≈ºda lista ma ID (int) i key (string) - mo≈ºna u≈ºywaƒá obu
4. Import markdown mo≈ºe tworzyƒá wiele powiƒÖzanych list
5. Delete list sprawdza powiƒÖzania (L1->L2)
6. Export do formatu [x] Task

Rozpocznij od core/models.py, potem database.py, manager.py (etap 1), i na ko≈Ñcu interfejsy.

--------------------

# TODOIT MCP - Inteligentny System List TODO

**TODOIT** (Todo It) - profesjonalny system zarzƒÖdzania listami TODO zoptymalizowany pod automatyzacjƒô i integracjƒô z AI.

## üéØ Cel i Problem

### Obecne problemy:
- LLM ma trudno≈õci z aktualizacjƒÖ plik√≥w markdown (czƒôste grepowanie)
- Brak struktury relacyjnej miƒôdzy zadaniami
- Trudno≈õci w ≈õledzeniu z≈Ço≈ºonych zale≈ºno≈õci miƒôdzy zadaniami
- Nieefektywne parsowanie wielostanowych zada≈Ñ w plikach tekstowych

### RozwiƒÖzanie:
TODOIT MCP - serwer Model Context Protocol z Programmatic API i bazƒÖ SQLite, oferujƒÖcy strukturalne zarzƒÖdzanie listami TODO.

## üèóÔ∏è Architektura

### Podej≈õcie: **Programmatic API + MCP Interface**

```
Claude Code <--stdio/MCP protocol--> MCP Server <--Programmatic API--> SQLite DB
                                          ‚îÇ
                                    TodoManager
                                   (Core Logic)
```

### Wyb√≥r technologii: **Python** 

**Dlaczego Python:**
- Najpopularniejszy jƒôzyk dla narzƒôdzi AI i automatyzacji
- SQLAlchemy - potƒô≈ºny ORM z migracjami
- ≈Åatwiejsza integracja z Claude Code i narzƒôdziami AI
- Type hints dla lepszej dokumentacji
- Prostota implementacji MCP

### Stack technologiczny:
- **Python 3.12+** (zgodnie z projektem)
- **MCP SDK** - oficjalny Python SDK od Anthropic
- **SQLAlchemy 2.0** - ORM z async support
- **SQLite** - lekka baza embedded
- **Pydantic** - walidacja danych i modele

## üìä Model Danych

### Tabele w SQLite:

```sql
-- G≈Ç√≥wna tabela list TODO
CREATE TABLE todo_lists (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    list_key TEXT UNIQUE NOT NULL,  -- np. "project_alpha", "shopping_weekly"
    title TEXT NOT NULL,
    description TEXT,
    list_type TEXT,  -- 'sequential', 'parallel', 'hierarchical'
    parent_list_id INTEGER REFERENCES todo_lists(id),
    metadata JSON,  -- dodatkowe dane jak project_id, tags, priority
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Pojedyncze zadania
CREATE TABLE todo_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    list_id INTEGER NOT NULL REFERENCES todo_lists(id),
    item_key TEXT NOT NULL,  -- lokalny klucz w ramach listy
    content TEXT NOT NULL,
    position INTEGER NOT NULL,  -- kolejno≈õƒá na li≈õcie
    status TEXT DEFAULT 'pending',  -- 'pending', 'in_progress', 'completed', 'failed'
    completion_states JSON,  -- dla multi-state jak {"tested": true, "deployed": false}
    parent_item_id INTEGER REFERENCES todo_items(id),
    metadata JSON,  -- np. assignee, due_date, priority, tags
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(list_id, item_key)
);

-- Relacje miƒôdzy listami
CREATE TABLE list_relations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_list_id INTEGER REFERENCES todo_lists(id),
    target_list_id INTEGER REFERENCES todo_lists(id),
    relation_type TEXT NOT NULL,  -- 'dependency', 'parent', 'related'
    relation_key TEXT,  -- np. project_id, sprint_id
    metadata JSON
);

-- Historia zmian (audit log)
CREATE TABLE todo_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    item_id INTEGER REFERENCES todo_items(id),
    list_id INTEGER REFERENCES todo_lists(id),
    action TEXT NOT NULL,  -- 'created', 'updated', 'completed', 'failed'
    old_value JSON,
    new_value JSON,
    user_context TEXT,  -- np. 'claude_code', 'manual', 'automation'
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## üìã Kompletna lista funkcji TODOIT (37 funkcji)

### Podstawowe operacje na listach
1. **create_list** - Tworzenie nowej listy TODO
   - Z opcjonalnymi zadaniami od razu
   - Z metadanymi (book_id, collection_name, itp.)
   - Z typem listy (sequential, parallel, hierarchical)

2. **get_list** - Pobieranie listy po kluczu
3. **update_list** - Aktualizacja metadanych listy
4. **delete_list** - Usuwanie listy (z opcjƒÖ kaskadowƒÖ)
5. **list_all** - Listowanie wszystkich list (z filtrowaniem)

### Operacje na zadaniach
6. **add_item** - Dodawanie pojedynczego zadania do listy
7. **update_item** - Aktualizacja tre≈õci zadania
8. **update_item_status** - Zmiana statusu (pending ‚Üí in_progress ‚Üí completed/failed)
9. **update_item_states** - Aktualizacja multi-state (np. generated: true, downloaded: false)
10. **delete_item** - Usuwanie zadania
11. **reorder_items** - Zmiana kolejno≈õci zada≈Ñ

### Rozszerzanie list
12. **append_items** - Dodawanie wielu zada≈Ñ na ko≈Ñcu listy
    - Automatyczne numerowanie pozycji
    - Zachowanie istniejƒÖcej kolejno≈õci
    - Opcja dodania na poczƒÖtku (prepend)

13. **extend_list** - Rozszerzenie listy o zadania z innej listy/≈∫r√≥d≈Ça
    - Import z pliku YAML z scenami
    - Kopiowanie z szablonu
    - Merge z innƒÖ listƒÖ

14. **insert_item** - Wstawienie zadania w konkretne miejsce
    - Z przesuniƒôciem kolejnych pozycji
    - Opcja wstawienia jako pod-zadanie

### Zapytania i wyszukiwanie
15. **get_next_pending** - Pobranie nastƒôpnego zadania do zrobienia
    - Z respektowaniem zale≈ºno≈õci parent/child
    - Z filtrowaniem po metadanych

16. **get_items_by_status** - Wszystkie zadania o danym statusie
17. **get_progress** - Statystyki postƒôpu listy (%, liczby)
18. **get_lists_by_relation** - Listy powiƒÖzane (np. przez thread_id, book_id)
19. **search_items** - Wyszukiwanie zada≈Ñ po tre≈õci/metadanych

### Operacje grupowe
20. **bulk_update** - Aktualizacja wielu zada≈Ñ jednocze≈õnie
21. **bulk_check** - Oznaczanie wielu zada≈Ñ jako wykonane
22. **clone_list** - Klonowanie listy (np. szablon dla nowej ksiƒÖ≈ºki)
23. **merge_lists** - ≈ÅƒÖczenie list

### Relacje i zale≈ºno≈õci
24. **set_item_dependency** - Ustawienie zale≈ºno≈õci miƒôdzy zadaniami
25. **create_list_relation** - PowiƒÖzanie list (thread, book, group)
26. **get_dependencies** - Pobranie drzewa zale≈ºno≈õci

### Analityka i raporty
27. **get_timeline** - Historia zmian zadania/listy
28. **get_blocked_items** - Zadania zablokowane przez zale≈ºno≈õci

### Import/Export
29. **import_from_markdown** - Import z pliku markdown (migracja)
30. **export_to_markdown** - Export do markdown

### Funkcje pomocnicze
31. **reset_item** - Reset zadania do stanu pending
32. **archive_list** - Archiwizacja uko≈Ñczonej listy
33. **get_item_metadata** - Pobranie/aktualizacja metadanych
34. **add_note** - Dodanie notatki do zadania

### Obs≈Çuga b≈Çƒôd√≥w i ponowne pr√≥by
35. **handle_failed** - Obs≈Çuga b≈Çƒôd√≥w w zadaniach
36. **retry_failed_items** - Ponowienie nieudanych zada≈Ñ
37. **get_stale_items** - Zadania rozpoczƒôte ale nieuko≈Ñczone (timeout)

## üìä Etapy wdro≈ºenia TODOIT

### Etap 1: Minimalny zestaw funkcji (10 funkcji)
- **create_list** - Tworzenie listy (pusta, z N elementami, z folderu)
- **get_list** - Pobieranie listy po ID lub nazwie
- **delete_list** - Usuwanie listy (z walidacjƒÖ powiƒÖza≈Ñ)
- **list_all** - Listowanie wszystkich list
- **add_item** - Dodawanie zadania
- **update_item_status** - Zmiana statusu zadania
- **get_next_pending** - Nastƒôpne zadanie do zrobienia
- **get_progress** - Postƒôp listy
- **import_from_markdown** - Import z [ ] [x]
- **export_to_markdown** - Export do [ ] [x]

### Etap 2: Rozszerzenie podstawowe (8 funkcji)
- **update_list** - Aktualizacja listy (analogicznie do create)
- **update_item** - Aktualizacja tre≈õci zadania
- **delete_item** - Usuwanie zadania
- **append_items** - Dodawanie wielu zada≈Ñ
- **get_items_by_status** - Filtrowanie po statusie
- **bulk_check** - Oznaczanie wielu jako wykonane
- **create_list_relation** - Tworzenie powiƒÖza≈Ñ miƒôdzy listami
- **get_lists_by_relation** - Pobieranie powiƒÖzanych list

### Etap 3: Rozszerzenie zaawansowane (10 funkcji)
- **update_item_states** - Multi-state completion
- **reorder_items** - Zmiana kolejno≈õci
- **extend_list** - Rozszerzanie z r√≥≈ºnych ≈∫r√≥de≈Ç
- **insert_item** - Wstawianie w konkretne miejsce
- **search_items** - Wyszukiwanie zada≈Ñ
- **bulk_update** - Aktualizacja grupowa
- **set_item_dependency** - Zale≈ºno≈õci miƒôdzy zadaniami
- **get_dependencies** - Drzewo zale≈ºno≈õci
- **get_timeline** - Historia zmian
- **get_blocked_items** - Zablokowane zadania

### Etap 4: Pe≈Çny zestaw (9 funkcji)
- **clone_list** - Klonowanie listy
- **merge_lists** - ≈ÅƒÖczenie list
- **reset_item** - Reset do pending
- **archive_list** - Archiwizacja
- **get_item_metadata** - ZarzƒÖdzanie metadanymi
- **add_note** - Notatki do zada≈Ñ
- **handle_failed** - Obs≈Çuga b≈Çƒôd√≥w
- **retry_failed_items** - Ponowne pr√≥by
- **get_stale_items** - Timeout detection

## üîß Programmatic API (Core)

### TodoManager - Centralna logika biznesowa:

```python
# core/manager.py
"""
TODOIT MCP - Todo It Manager
Programmatic API dla zarzƒÖdzania listami TODO
"""
from typing import List, Optional, Dict, Any, Union
from datetime import datetime
from .models import TodoList, TodoItem, CompletionStates
from .database import Database

class TodoManager:
    """Programmatic API dla zarzƒÖdzania TODO - core business logic"""
    
    def __init__(self, db_path: str = "todoit.db"):
        self.db = Database(db_path)
    
    # === ZarzƒÖdzanie listami ===
    
    def create_list(self, 
                   key: str, 
                   title: str, 
                   items: Optional[List[str]] = None,
                   list_type: str = "sequential",
                   metadata: Optional[Dict] = None) -> TodoList:
        """Tworzy nowƒÖ listƒô TODO z opcjonalnymi zadaniami"""
        if self.get_list(key):
            raise ValueError(f"Lista '{key}' ju≈º istnieje")
        
        # Tworzenie listy
        list_id = self.db.insert("todo_lists", {
            "list_key": key,
            "title": title,
            "list_type": list_type,
            "metadata": metadata or {}
        })
        
        # Dodawanie zada≈Ñ je≈õli podane
        if items:
            for position, content in enumerate(items):
                self.add_item(key, f"item_{position}", content, position)
        
        return self.get_list(key)
    
    def export_to_markdown(self, list_key: str, file_path: str) -> None:
        """Eksportuje listƒô do formatu markdown [x] tekst"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        items = self.db.get_list_items(todo_list.id)
        
        with open(file_path, 'w') as f:
            for item in sorted(items, key=lambda x: x.position):
                status = '[x]' if item.status == 'completed' else '[ ]'
                f.write(f"{status} {item.content}\n")
    
    def delete_list(self, key: Union[str, int]) -> bool:
        """Usuwa listƒô (z walidacjƒÖ powiƒÖza≈Ñ)"""
        todo_list = self.get_list(key)
        if not todo_list:
            raise ValueError(f"Lista '{key}' nie istnieje")
        
        # Sprawd≈∫ czy lista ma zale≈ºne listy
        dependent_lists = self.db.get_dependent_lists(todo_list.id)
        if dependent_lists:
            deps = ", ".join([l.list_key for l in dependent_lists])
            raise ValueError(f"Nie mo≈ºna usunƒÖƒá listy '{key}' - ma zale≈ºne listy: {deps}")
        
        # Usu≈Ñ wszystkie zadania
        self.db.delete_list_items(todo_list.id)
        
        # Usu≈Ñ relacje gdzie lista jest ≈∫r√≥d≈Çem
        self.db.delete_list_relations(todo_list.id)
        
        # Usu≈Ñ listƒô
        self.db.delete("todo_lists", todo_list.id)
        
        return True
    
    def get_list(self, key: Union[str, int]) -> Optional[TodoList]:
        """Pobiera listƒô po kluczu lub ID"""
        # Sprawd≈∫ czy key to liczba (ID)
        if isinstance(key, int) or (isinstance(key, str) and key.isdigit()):
            return self.db.get_list_by_id(int(key))
        else:
            return self.db.get_list_by_key(key)
    
    def update_list(self, key: Union[str, int], title: str = None, metadata: Dict = None) -> TodoList:
        """Aktualizuje dane listy"""
        todo_list = self.get_list(key)
        if not todo_list:
            raise ValueError(f"Lista '{key}' nie istnieje")
        
        updates = {}
        if title:
            updates["title"] = title
        if metadata:
            current_meta = todo_list.metadata or {}
            current_meta.update(metadata)
            updates["metadata"] = current_meta
        
        if updates:
            updates["updated_at"] = datetime.now()
            self.db.update("todo_lists", todo_list.id, updates)
        
        return self.get_list(key)
    
    def get_lists_by_relation(self, 
                             relation_type: str, 
                             relation_key: str) -> List[TodoList]:
        """Pobiera listy powiƒÖzane relacjƒÖ (np. project_id)"""
        return self.db.get_lists_by_relation(relation_type, relation_key)
    
    # === Rozszerzanie list ===
    
    def append_items(self,
                    list_key: str,
                    items: List[Dict[str, Any]]) -> List[TodoItem]:
        """Dodaje wiele zada≈Ñ na ko≈Ñcu listy"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        # Pobierz najwy≈ºszƒÖ pozycjƒô
        last_position = self.db.get_max_position(todo_list.id)
        
        created_items = []
        for i, item_data in enumerate(items):
            if isinstance(item_data, str):
                # Prosty string jako content
                content = item_data
                item_key = f"appended_{last_position + i + 1}"
                metadata = {}
            else:
                # S≈Çownik z pe≈Çnymi danymi
                content = item_data.get("content", "")
                item_key = item_data.get("key", f"appended_{last_position + i + 1}")
                metadata = item_data.get("metadata", {})
            
            item = self.add_item(
                list_key=list_key,
                item_key=item_key,
                content=content,
                position=last_position + i + 1,
                metadata=metadata
            )
            created_items.append(item)
        
        return created_items
    
    def extend_list(self,
                   list_key: str,
                   source_list_key: str = None,
                   source_file: str = None,
                   items: List[str] = None) -> int:
        """Rozszerza listƒô o zadania z innego ≈∫r√≥d≈Ça"""
        if source_list_key:
            # Kopiowanie z innej listy
            source_list = self.get_list(source_list_key)
            if not source_list:
                raise ValueError(f"Lista ≈∫r√≥d≈Çowa '{source_list_key}' nie istnieje")
            
            source_items = self.db.get_list_items(source_list.id)
            items_to_add = [
                {
                    "content": item.content,
                    "metadata": {**item.metadata, "copied_from": source_list_key}
                }
                for item in source_items
            ]
            
        elif source_file:
            # Import z pliku YAML (np. lista zada≈Ñ)
            import yaml
            with open(source_file, 'r') as f:
                data = yaml.safe_load(f)
                items_to_add = [
                    {"content": task["name"], "metadata": task}
                    for task in data.get("tasks", [])
                ]
                
        elif items:
            # Bezpo≈õrednia lista zada≈Ñ
            items_to_add = [{"content": item} for item in items]
        else:
            raise ValueError("Musisz podaƒá source_list_key, source_file lub items")
        
        added_items = self.append_items(list_key, items_to_add)
        return len(added_items)
    
    def insert_item(self,
                   list_key: str,
                   item_key: str,
                   content: str,
                   position: int = None,
                   after_item_key: str = None,
                   metadata: Optional[Dict] = None) -> TodoItem:
        """Wstawia zadanie w konkretne miejsce listy"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        if after_item_key:
            # Wstaw po konkretnym zadaniu
            after_item = self.get_item(list_key, after_item_key)
            if not after_item:
                raise ValueError(f"Zadanie '{after_item_key}' nie istnieje")
            position = after_item.position + 1
        elif position is None:
            raise ValueError("Musisz podaƒá position lub after_item_key")
        
        # Przesu≈Ñ wszystkie zadania od tej pozycji w g√≥rƒô
        self.db.shift_positions(todo_list.id, position, 1)
        
        # Wstaw nowe zadanie
        return self.add_item(
            list_key=list_key,
            item_key=item_key,
            content=content,
            position=position,
            metadata=metadata
        )
    
    # === ZarzƒÖdzanie zadaniami ===
    
    def add_item(self, 
                list_key: str, 
                item_key: str, 
                content: str,
                position: Optional[int] = None,
                metadata: Optional[Dict] = None) -> TodoItem:
        """Dodaje zadanie do listy"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        if position is None:
            position = self.db.get_next_position(todo_list.id)
        
        item_id = self.db.insert("todo_items", {
            "list_id": todo_list.id,
            "item_key": item_key,
            "content": content,
            "position": position,
            "metadata": metadata or {}
        })
        
        return self.get_item(list_key, item_key)
    
    def update_item_status(self, 
                          list_key: str, 
                          item_key: str,
                          status: Optional[str] = None,
                          completion_states: Optional[Dict[str, bool]] = None) -> TodoItem:
        """Aktualizuje status zadania z obs≈ÇugƒÖ multi-state"""
        item = self.get_item(list_key, item_key)
        if not item:
            raise ValueError(f"Zadanie '{item_key}' nie istnieje w li≈õcie '{list_key}'")
        
        updates = {}
        if status:
            updates["status"] = status
            if status == "in_progress":
                updates["started_at"] = datetime.now()
            elif status in ["completed", "failed"]:
                updates["completed_at"] = datetime.now()
        
        if completion_states:
            current_states = item.completion_states or {}
            current_states.update(completion_states)
            updates["completion_states"] = current_states
        
        self.db.update_item(item.id, updates)
        self._record_history(item.id, "updated", updates)
        
        return self.get_item(list_key, item_key)
    
    def get_next_pending(self, 
                        list_key: str,
                        respect_dependencies: bool = True) -> Optional[TodoItem]:
        """Pobiera nastƒôpne zadanie do wykonania"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            return None
        
        items = self.db.get_items_by_status(todo_list.id, "pending")
        
        if not respect_dependencies:
            return items[0] if items else None
        
        # Sprawdzanie zale≈ºno≈õci
        for item in items:
            # Sprawd≈∫ zale≈ºno≈õci parent/child
            if item.parent_item_id:
                parent = self.db.get_item_by_id(item.parent_item_id)
                if parent.status != "completed":
                    continue
            
            # Sprawd≈∫ zale≈ºno≈õci miƒôdzy listami (dla list powiƒÖzanych)
            dependencies = self.db.get_list_dependencies(todo_list.id)
            if dependencies:
                # Dla list powiƒÖzanych sprawd≈∫ czy odpowiedni item w poprzedniej li≈õcie jest completed
                can_proceed = True
                for dep in dependencies:
                    if dep.metadata.get("rule") == "item_n_requires_item_n":
                        # Znajd≈∫ odpowiadajƒÖcy item w li≈õcie ≈∫r√≥d≈Çowej
                        source_item = self.db.get_item_at_position(dep.source_list_id, item.position)
                        if source_item and source_item.status != "completed":
                            can_proceed = False
                            break
                
                if not can_proceed:
                    continue
            
            return item
        
        return None
    
    def get_progress(self, list_key: str) -> Dict[str, Any]:
        """Zwraca postƒôp realizacji listy"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        stats = self.db.get_list_stats(todo_list.id)
        return {
            "total": stats["total"],
            "completed": stats["completed"],
            "in_progress": stats["in_progress"],
            "pending": stats["pending"],
            "failed": stats["failed"],
            "completion_percentage": (stats["completed"] / stats["total"] * 100) 
                                   if stats["total"] > 0 else 0
        }
    
    # === Operacje bulk ===
    
    def bulk_update(self, 
                   list_key: str,
                   filter_criteria: Dict[str, Any],
                   updates: Dict[str, Any]) -> int:
        """Aktualizuje wiele zada≈Ñ jednocze≈õnie"""
        todo_list = self.get_list(list_key)
        if not todo_list:
            raise ValueError(f"Lista '{list_key}' nie istnieje")
        
        affected_items = self.db.bulk_update_items(
            todo_list.id, 
            filter_criteria, 
            updates
        )
        
        return len(affected_items)
    
    # === Import/Export ===
    
    def import_from_markdown(self, file_path: str, base_key: str = None) -> List[TodoList]:
        """Importuje listy z pliku markdown (obs≈Çuguje multi-column)"""
        lists_data = {}
        
        with open(file_path, 'r') as f:
            for line in f:
                if line.strip().startswith('['):
                    # Parsowanie wszystkich kolumn [ ] lub [x]
                    columns = []
                    content = line.strip()
                    
                    # WyciƒÖgnij wszystkie stany
                    while content.startswith('['):
                        state = content[1] == 'x'
                        columns.append(state)
                        content = content[4:]  # Skip [x] lub [ ]
                    
                    # Dla ka≈ºdej kolumny tworzymy osobnƒÖ listƒô
                    for i, state in enumerate(columns):
                        if i not in lists_data:
                            lists_data[i] = []
                        lists_data[i].append({
                            "content": content.strip(),
                            "completed": state,
                            "position": len(lists_data[i])
                        })
        
        # Tworzenie list
        created_lists = []
        base_key = base_key or f"import_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        for i, items in lists_data.items():
            list_key = f"{base_key}_col{i+1}" if len(lists_data) > 1 else base_key
            todo_list = self.create_list(
                key=list_key,
                title=f"Imported list {i+1}" if len(lists_data) > 1 else "Imported list"
            )
            
            # Dodawanie zada≈Ñ
            for item in items:
                self.add_item(
                    list_key,
                    f"item_{item['position']}",
                    item["content"],
                    position=item["position"]
                )
                
                if item["completed"]:
                    self.update_item_status(
                        list_key,
                        f"item_{item['position']}",
                        status="completed"
                    )
            
            created_lists.append(todo_list)
        
        # Tworzenie powiƒÖza≈Ñ miƒôdzy listami (lista N+1 zale≈ºy od listy N)
        for i in range(len(created_lists) - 1):
            self.create_list_relation(
                source_list_id=created_lists[i].id,
                target_list_id=created_lists[i+1].id,
                relation_type="dependency",
                metadata={"rule": "item_n_requires_item_n"}
            )
        
        return created_lists
    
    def _record_history(self, item_id: int, action: str, changes: Dict):
        """Zapisuje zmianƒô do historii"""
        self.db.insert("todo_history", {
            "item_id": item_id,
            "action": action,
            "new_value": changes,
            "user_context": "programmatic_api"
        })
```

## üîå MCP Server Interface

### Implementacja serwera MCP:

```python
# interfaces/mcp_server.py
"""
TODOIT MCP Server
Interface MCP dla systemu zarzƒÖdzania TODO
"""
import asyncio
from typing import Any
from mcp.server import Server
from mcp.server.stdio import stdio_server
from core.manager import TodoManager

class TodoMCPServer:
    """MCP Server interface dla TodoManager"""
    
    def __init__(self, db_path: str = "todoit.db"):
        self.manager = TodoManager(db_path)
        self.server = Server("todoit")
        self._register_tools()
    
    def _register_tools(self):
        """Rejestruje wszystkie narzƒôdzia MCP"""
        
        @self.server.tool()
        async def todo_create_list(arguments: dict) -> dict:
            """Tworzy nowƒÖ listƒô TODO"""
            try:
                todo_list = self.manager.create_list(
                    key=arguments["list_key"],
                    title=arguments["title"],
                    items=arguments.get("items"),
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "list": todo_list.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_add_item(arguments: dict) -> dict:
            """Dodaje zadanie do listy"""
            try:
                item = self.manager.add_item(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    content=arguments["content"],
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_append_items(arguments: dict) -> dict:
            """Dodaje wiele zada≈Ñ na ko≈Ñcu listy"""
            try:
                items = self.manager.append_items(
                    list_key=arguments["list_key"],
                    items=arguments["items"]
                )
                return {
                    "success": True,
                    "added_count": len(items),
                    "items": [item.to_dict() for item in items]
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_extend_list(arguments: dict) -> dict:
            """Rozszerza listƒô o zadania z innego ≈∫r√≥d≈Ça"""
            try:
                count = self.manager.extend_list(
                    list_key=arguments["list_key"],
                    source_list_key=arguments.get("source_list_key"),
                    source_file=arguments.get("source_file"),
                    items=arguments.get("items")
                )
                return {
                    "success": True,
                    "extended_count": count
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_insert_item(arguments: dict) -> dict:
            """Wstawia zadanie w konkretne miejsce listy"""
            try:
                item = self.manager.insert_item(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    content=arguments["content"],
                    position=arguments.get("position"),
                    after_item_key=arguments.get("after_item_key"),
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_check_item(arguments: dict) -> dict:
            """Oznacza zadanie jako wykonane/niewykonane"""
            try:
                states = arguments.get("states", {})
                status = arguments.get("status")
                
                # Automatyczne ustawienie statusu na podstawie stan√≥w
                if not status and states:
                    if all(states.values()):
                        status = "completed"
                    elif any(states.values()):
                        status = "in_progress"
                
                item = self.manager.update_item_status(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    status=status,
                    completion_states=states
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_next(arguments: dict) -> dict:
            """Pobiera nastƒôpne zadanie do wykonania"""
            try:
                item = self.manager.get_next_pending(
                    list_key=arguments["list_key"],
                    respect_dependencies=arguments.get("respect_dependencies", True)
                )
                if item:
                    return {
                        "success": True,
                        "item": item.to_dict()
                    }
                else:
                    return {
                        "success": True,
                        "item": None,
                        "message": "Brak zada≈Ñ do wykonania"
                    }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_progress(arguments: dict) -> dict:
            """Pobiera postƒôp listy"""
            try:
                progress = self.manager.get_progress(arguments["list_key"])
                return {
                    "success": True,
                    "progress": progress
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_by_project(arguments: dict) -> dict:
            """Pobiera listy powiƒÖzane z project_id"""
            try:
                lists = self.manager.get_lists_by_relation(
                    relation_type="project",
                    relation_key=arguments["project_id"]
                )
                return {
                    "success": True,
                    "lists": [l.to_dict() for l in lists]
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_bulk_update(arguments: dict) -> dict:
            """Aktualizuje wiele zada≈Ñ jednocze≈õnie"""
            try:
                count = self.manager.bulk_update(
                    list_key=arguments["list_key"],
                    filter_criteria=arguments.get("filter", {}),
                    updates=arguments["updates"]
                )
                return {
                    "success": True,
                    "updated_count": count
                }
            except Exception as e:
                return {"success": False, "error": str(e)}

async def main():
    """Uruchamia serwer MCP"""
    server = TodoMCPServer()
    async with stdio_server() as streams:
        await server.server.run(streams[0], streams[1])

if __name__ == "__main__":
    asyncio.run(main())
```

## üñ•Ô∏è CLI Interface (Rich)

### Implementacja CLI z bibliotekƒÖ Rich:

```python
# interfaces/cli.py
"""
TODOIT CLI
Command Line Interface z u≈ºyciem Rich dla lepszej prezentacji
"""
import click
import json
from typing import Optional, List
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.tree import Tree
from rich.syntax import Syntax
from rich.prompt import Prompt, Confirm
from rich.layout import Layout
from rich import box
from core.manager import TodoManager

console = Console()
manager = TodoManager()

# === G≈Ç√≥wna grupa komend ===

@click.group()
@click.option('--db', default='todoit.db', help='≈öcie≈ºka do bazy danych')
@click.pass_context
def cli(ctx, db):
    """TODOIT - Inteligentny system zarzƒÖdzania TODO"""
    ctx.ensure_object(dict)
    ctx.obj['manager'] = TodoManager(db)
    global manager
    manager = ctx.obj['manager']

# === Komendy list ===

@cli.group()
def list():
    """ZarzƒÖdzanie listami TODO"""
    pass

@list.command('create')
@click.argument('key')
@click.option('--title', help='Tytu≈Ç listy')
@click.option('-n', '--count', type=int, help='Liczba element√≥w do utworzenia')
@click.option('-t', '--template', help='Szablon tekstu (numer dodawany na ko≈Ñcu)')
@click.option('-d', '--directory', help='Folder z plikami do dodania')
@click.option('--type', default='sequential', type=click.Choice(['sequential', 'parallel', 'hierarchical']))
@click.option('--metadata', '-m', help='Metadata JSON')
def list_create(key, title, count, template, directory, type, metadata):
    """Tworzy nowƒÖ listƒô TODO"""
    with console.status(f"[bold green]Tworzenie listy '{key}'..."):
        try:
            items = None
            
            # Generowanie element√≥w na podstawie opcji
            if count and template:
                # Automatyczna numeracja
                items = [f"{template} {i}" for i in range(1, count + 1)]
            elif directory:
                # Lista plik√≥w z folderu
                import os
                files = sorted(os.listdir(directory))
                items = [f"{template}{f}" if template else f for f in files]
            
            # Je≈õli nie podano tytu≈Çu, u≈ºyj klucza
            if not title:
                title = key.replace('_', ' ').replace('-', ' ').title()
            
            meta = json.loads(metadata) if metadata else {}
            todo_list = manager.create_list(
                key=key,
                title=title,
                items=items,
                list_type=type,
                metadata=meta
            )
            
            # Wy≈õwietl utworzonƒÖ listƒô
            panel = Panel(
                f"[bold cyan]ID:[/] {todo_list.id}\n"
                f"[bold cyan]Tytu≈Ç:[/] {todo_list.title}\n"
                f"[bold cyan]Klucz:[/] {todo_list.list_key}\n"
                f"[bold cyan]Typ:[/] {todo_list.list_type}\n"
                f"[bold cyan]Zada≈Ñ:[/] {len(items) if items else 0}",
                title="‚úÖ Lista utworzona",
                border_style="green"
            )
            console.print(panel)
            
        except Exception as e:
            console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@list.command('update')
@click.argument('key')
@click.option('--title', help='Nowy tytu≈Ç listy')
@click.option('-n', '--count', type=int, help='Liczba element√≥w do dodania')
@click.option('-t', '--template', help='Szablon tekstu dla nowych element√≥w')
@click.option('-d', '--directory', help='Folder z plikami do dodania')
@click.option('--metadata', '-m', help='Metadata JSON do aktualizacji')
def list_update(key, title, count, template, directory, metadata):
    """Aktualizuje listƒô TODO (dodaje elementy lub zmienia metadane)"""
    try:
        todo_list = manager.get_list(key)
        if not todo_list:
            console.print(f"[red]Lista '{key}' nie istnieje[/]")
            return
        
        # Aktualizacja tytu≈Çu
        if title:
            manager.update_list(key, title=title)
        
        # Dodawanie nowych element√≥w
        items_to_add = []
        if count and template:
            # Pobierz aktualnƒÖ liczbƒô element√≥w dla kontynuacji numeracji
            current_items = manager.db.get_list_items(todo_list.id)
            start_num = len(current_items) + 1
            items_to_add = [f"{template} {i}" for i in range(start_num, start_num + count)]
        elif directory:
            import os
            files = sorted(os.listdir(directory))
            items_to_add = [f"{template}{f}" if template else f for f in files]
        
        if items_to_add:
            manager.append_items(key, items_to_add)
        
        # Aktualizacja metadanych
        if metadata:
            meta = json.loads(metadata)
            manager.update_list(key, metadata=meta)
        
        console.print(f"[green]‚úÖ Zaktualizowano listƒô '{key}'[/]")
        
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@list.command('show')
@click.argument('key')
@click.option('--tree', is_flag=True, help='Wy≈õwietl jako drzewo')
def list_show(key, tree):
    """Wy≈õwietla szczeg√≥≈Çy listy"""
    try:
        todo_list = manager.get_list(key)
        if not todo_list:
            console.print(f"[red]Lista '{key}' nie istnieje[/]")
            return
        
        items = manager.db.get_list_items(todo_list.id)
        
        if tree:
            # Widok drzewa
            tree = Tree(f"üìã {todo_list.title} ({todo_list.list_key})")
            
            for item in items:
                status_icon = {
                    'pending': '‚è≥',
                    'in_progress': 'üîÑ',
                    'completed': '‚úÖ',
                    'failed': '‚ùå'
                }.get(item.status, '‚ùì')
                
                node = tree.add(f"{status_icon} {item.content}")
                
                # Dodaj stany completion je≈õli istniejƒÖ
                if item.completion_states:
                    for state, value in item.completion_states.items():
                        icon = '‚úÖ' if value else '‚ùå'
                        node.add(f"{icon} {state}")
            
            console.print(tree)
        else:
            # Widok tabeli
            table = Table(title=f"üìã {todo_list.title} (ID: {todo_list.id})", box=box.ROUNDED)
            table.add_column("#", style="cyan", width=4)
            table.add_column("Klucz", style="magenta")
            table.add_column("Zadanie", style="white")
            table.add_column("Status", style="yellow")
            table.add_column("Stany", style="blue")
            
            for item in items:
                status_style = {
                    'pending': 'yellow',
                    'in_progress': 'blue',
                    'completed': 'green',
                    'failed': 'red'
                }.get(item.status, 'white')
                
                states_str = ""
                if item.completion_states:
                    states = [f"{'‚úÖ' if v else '‚ùå'}{k}" for k, v in item.completion_states.items()]
                    states_str = " ".join(states)
                
                table.add_row(
                    str(item.position),
                    item.item_key,
                    item.content,
                    f"[{status_style}]{item.status}[/]",
                    states_str
                )
            
            console.print(table)
            
            # Poka≈º postƒôp
            progress = manager.get_progress(key)
            console.print(f"\n[bold]Lista ID:[/] {todo_list.id}")
            console.print(f"[bold]Postƒôp:[/] {progress['completion_percentage']:.1f}% "
                         f"({progress['completed']}/{progress['total']})")
            
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@list.command('delete')
@click.argument('key')
@click.option('--force', is_flag=True, help='Wymu≈õ usuniƒôcie')
def list_delete(key, force):
    """Usuwa listƒô TODO (z walidacjƒÖ powiƒÖza≈Ñ)"""
    try:
        todo_list = manager.get_list(key)
        if not todo_list:
            console.print(f"[red]Lista '{key}' nie istnieje[/]")
            return
        
        if not force and not Confirm.ask(f"Czy na pewno chcesz usunƒÖƒá listƒô '{key}'?"):
            return
        
        manager.delete_list(key)
        console.print(f"[green]‚úÖ Usuniƒôto listƒô '{key}'[/]")
        
    except ValueError as e:
        console.print(f"[bold red]‚ùå {e}[/]")
        console.print("[yellow]Wskaz√≥wka: Najpierw usu≈Ñ listy zale≈ºne[/]")
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@list.command('all')
@click.option('--filter', '-f', help='Filtruj po metadata (JSON)')
def list_all(filter):
    """Wy≈õwietla wszystkie listy"""
    try:
        lists = manager.db.get_all_lists()
        
        if filter:
            filter_dict = json.loads(filter)
            lists = [l for l in lists if all(
                l.metadata.get(k) == v for k, v in filter_dict.items()
            )]
        
        table = Table(title="üìã Wszystkie listy TODO", box=box.ROUNDED)
        table.add_column("ID", style="dim", width=4)
        table.add_column("Klucz", style="cyan")
        table.add_column("Tytu≈Ç", style="white")
        table.add_column("Typ", style="yellow")
        table.add_column("Zada≈Ñ", style="green")
        table.add_column("Uko≈Ñczone", style="blue")
        table.add_column("Postƒôp", style="magenta")
        
        for todo_list in lists:
            progress = manager.get_progress(todo_list.list_key)
            table.add_row(
                str(todo_list.id),
                todo_list.list_key,
                todo_list.title,
                todo_list.list_type,
                str(progress['total']),
                str(progress['completed']),
                f"{progress['completion_percentage']:.1f}%"
            )
        
        console.print(table)
        console.print(f"\n[bold]≈ÅƒÖcznie list:[/] {len(lists)}")
        
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

# === Komendy zada≈Ñ ===

@cli.group()
def item():
    """ZarzƒÖdzanie zadaniami"""
    pass

@item.command('add')
@click.argument('list_key')
@click.argument('item_key')
@click.argument('content')
@click.option('--metadata', '-m', help='Metadata JSON')
def item_add(list_key, item_key, content, metadata):
    """Dodaje zadanie do listy"""
    try:
        meta = json.loads(metadata) if metadata else {}
        item = manager.add_item(
            list_key=list_key,
            item_key=item_key,
            content=content,
            metadata=meta
        )
        console.print(f"[green]‚úÖ Dodano zadanie '{item_key}' do listy '{list_key}'[/]")
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@item.command('check')
@click.argument('list_key')
@click.argument('item_key')
@click.option('--status', type=click.Choice(['completed', 'failed', 'in_progress']))
@click.option('--state', '-s', multiple=True, help='Stan w formacie klucz=warto≈õƒá')
def item_check(list_key, item_key, status, state):
    """Oznacza zadanie jako wykonane/zmienia stan"""
    try:
        states = {}
        for s in state:
            k, v = s.split('=')
            states[k] = v.lower() in ['true', '1', 'yes']
        
        item = manager.update_item_status(
            list_key=list_key,
            item_key=item_key,
            status=status,
            completion_states=states if states else None
        )
        
        console.print(f"[green]‚úÖ Zaktualizowano '{item_key}'[/]")
        if states:
            console.print("Stany:")
            for k, v in states.items():
                icon = '‚úÖ' if v else '‚ùå'
                console.print(f"  {icon} {k}")
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@item.command('next')
@click.argument('list_key')
@click.option('--start', is_flag=True, help='Rozpocznij zadanie')
def item_next(list_key, start):
    """Pobiera nastƒôpne zadanie do wykonania"""
    try:
        item = manager.get_next_pending(list_key)
        if not item:
            console.print(f"[yellow]Brak zada≈Ñ do wykonania w li≈õcie '{list_key}'[/]")
            return
        
        panel = Panel(
            f"[bold cyan]Zadanie:[/] {item.content}\n"
            f"[bold cyan]Klucz:[/] {item.item_key}\n"
            f"[bold cyan]Pozycja:[/] {item.position}",
            title="‚è≠Ô∏è Nastƒôpne zadanie",
            border_style="cyan"
        )
        console.print(panel)
        
        if start and Confirm.ask("RozpoczƒÖƒá to zadanie?"):
            manager.update_item_status(list_key, item.item_key, status='in_progress')
            console.print("[green]‚úÖ Zadanie rozpoczƒôte[/]")
            
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

# === Komendy rozszerzania ===

@item.command('append')
@click.argument('list_key')
@click.argument('items', nargs=-1, required=True)
def item_append(list_key, items):
    """Dodaje wiele zada≈Ñ na ko≈Ñcu listy"""
    try:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            task = progress.add_task(f"Dodawanie {len(items)} zada≈Ñ...", total=len(items))
            
            created = manager.append_items(list_key, list(items))
            
            for i, item in enumerate(created):
                progress.update(task, advance=1, description=f"Dodano: {item.content}")
        
        console.print(f"[green]‚úÖ Dodano {len(created)} zada≈Ñ do listy '{list_key}'[/]")
        
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

# === Komendy analityczne ===

@cli.group()
def stats():
    """Statystyki i raporty"""
    pass

@stats.command('progress')
@click.argument('list_key')
@click.option('--detailed', is_flag=True, help='Szczeg√≥≈Çowe statystyki')
def stats_progress(list_key, detailed):
    """Wy≈õwietla postƒôp listy"""
    try:
        progress = manager.get_progress(list_key)
        todo_list = manager.get_list(list_key)
        
        # Panel z postƒôpem
        panel = Panel(
            f"[bold cyan]Lista:[/] {todo_list.title}\n"
            f"[bold cyan]Uko≈Ñczone:[/] {progress['completed']}/{progress['total']} "
            f"({progress['completion_percentage']:.1f}%)\n"
            f"[bold cyan]W trakcie:[/] {progress['in_progress']}\n"
            f"[bold cyan]OczekujƒÖce:[/] {progress['pending']}\n"
            f"[bold cyan]Nieudane:[/] {progress['failed']}",
            title="üìä Postƒôp realizacji",
            border_style="blue"
        )
        console.print(panel)
        
        if detailed:
            # Wykres postƒôpu
            total = progress['total']
            if total > 0:
                completed_bar = '‚ñà' * int(progress['completed'] / total * 30)
                in_progress_bar = '‚ñí' * int(progress['in_progress'] / total * 30)
                pending_bar = '‚ñë' * int(progress['pending'] / total * 30)
                
                console.print(f"\n[green]{completed_bar}[/][yellow]{in_progress_bar}[/][dim]{pending_bar}[/]")
                
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

# === Komendy importu/exportu ===

@cli.group()
def io():
    """Import/Export danych"""
    pass

@io.command('import')
@click.argument('file_path')
@click.option('--key', help='Bazowy klucz dla importowanych list')
def io_import(file_path, key):
    """Importuje listy z pliku markdown (obs≈Çuguje multi-column)"""
    try:
        with console.status(f"[bold green]Importowanie z {file_path}..."):
            lists = manager.import_from_markdown(file_path, base_key=key)
        
        if len(lists) == 1:
            console.print(f"[green]‚úÖ Zaimportowano 1 listƒô: '{lists[0].list_key}'[/]")
        else:
            console.print(f"[green]‚úÖ Zaimportowano {len(lists)} powiƒÖzanych list:[/]")
            for i, lst in enumerate(lists):
                relation = " ‚Üí zale≈ºy od poprzedniej" if i > 0 else ""
                console.print(f"  ‚Ä¢ {lst.list_key}{relation}")
        
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

@io.command('export')
@click.argument('list_key')
@click.argument('file_path')
def io_export(list_key, file_path):
    """Eksportuje listƒô do markdown [x] format"""
    try:
        manager.export_to_markdown(list_key, file_path)
        console.print(f"[green]‚úÖ Wyeksportowano listƒô '{list_key}' do {file_path}[/]")
    except Exception as e:
        console.print(f"[bold red]‚ùå B≈ÇƒÖd:[/] {e}")

# === Interaktywny tryb ===

@cli.command()
def interactive():
    """Tryb interaktywny z menu"""
    console.print(Panel.fit(
        "[bold cyan]TODOIT - Tryb Interaktywny[/]\n"
        "Wpisz 'help' aby zobaczyƒá dostƒôpne komendy",
        border_style="cyan"
    ))
    
    while True:
        try:
            command = Prompt.ask("\n[bold cyan]todoit>[/]")
            
            if command.lower() in ['exit', 'quit', 'q']:
                break
            elif command.lower() == 'help':
                console.print("""
[bold]Dostƒôpne komendy:[/]
  lists          - Poka≈º wszystkie listy
  show <key>     - Poka≈º szczeg√≥≈Çy listy
  next <key>     - Nastƒôpne zadanie z listy
  check <key> <item> - Oznacz zadanie jako wykonane
  progress <key> - Poka≈º postƒôp listy
  help          - Ta pomoc
  exit          - Wyj≈õcie
                """)
            elif command.startswith('lists'):
                ctx = click.Context(list_all)
                list_all.invoke(ctx)
            elif command.startswith('show '):
                key = command.split()[1]
                ctx = click.Context(list_show)
                list_show.invoke(ctx, key=key, tree=False)
            elif command.startswith('next '):
                key = command.split()[1]
                ctx = click.Context(item_next)
                item_next.invoke(ctx, list_key=key, start=False)
            elif command.startswith('progress '):
                key = command.split()[1]
                ctx = click.Context(stats_progress)
                stats_progress.invoke(ctx, list_key=key, detailed=True)
            else:
                console.print(f"[red]Nieznana komenda: {command}[/]")
                
        except Exception as e:
            console.print(f"[red]B≈ÇƒÖd: {e}[/]")
    
    console.print("[yellow]Do zobaczenia! üëã[/]")

if __name__ == '__main__':
    cli()
```

### Przyk≈Çady u≈ºycia CLI:

```bash
# Tworzenie pustej listy
todoit list create 0004_brave_new_world-generowanie_obraz√≥w

# Tworzenie listy z N elementami (automatyczna numeracja)
todoit list create projekt_alpha -n 10 -t "Zadanie nr"
# Tworzy: "Zadanie nr 1", "Zadanie nr 2", ..., "Zadanie nr 10"

# Tworzenie listy na podstawie plik√≥w w folderze
todoit list create deployment_tasks -t "Deploy " -d /deploy/configs/
# Tworzy: "Deploy config1.yaml", "Deploy config2.yaml", ...

# Import z markdown (automatyczne powiƒÖzania dla multi-column)
todoit io import TODO-LISTS.md
# [x] [ ] Zadanie 1 ‚Üí tworzy 2 powiƒÖzane listy
# [x] [x] Zadanie 2 ‚Üí gdzie lista2[N] wymaga lista1[N] = completed

# Aktualizacja listy (analogicznie do create)
todoit list update projekt_alpha -n 5 -t "Nowe zadanie nr"

# U≈ºycie ID lub nazwy
todoit list show 42              # przez ID
todoit list show projekt_alpha   # przez nazwƒô

# Usuwanie z walidacjƒÖ powiƒÖza≈Ñ
todoit list delete lista1
# Error: Cannot delete lista1 - has dependent list: lista2

# Export do formatu [x]
todoit io export projekt_alpha tasks.md
# Generuje: [x] Zadanie 1
#          [ ] Zadanie 2

# Inne operacje
todoit item check projekt_alpha task_1
todoit item next projekt_alpha --start
todoit stats progress deployment --detailed
todoit item append shopping "Mas≈Ço" "Ser" "Jogurt"

# Tryb interaktywny
todoit interactive
```

### Konfiguracja Rich dla lepszego wyglƒÖdu:

```python
# config/cli_theme.py
from rich.theme import Theme

TODOIT_THEME = Theme({
    "info": "cyan",
    "warning": "yellow",
    "error": "bold red",
    "success": "bold green",
    "pending": "yellow",
    "in_progress": "blue",
    "completed": "green",
    "failed": "red"
})
```

## üîå MCP Server Interface

### Implementacja serwera MCP:

```python
# interfaces/mcp_server.py
"""
TODOIT MCP Server
Interface MCP dla systemu zarzƒÖdzania TODO
"""
import asyncio
from typing import Any
from mcp.server import Server
from mcp.server.stdio import stdio_server
from core.manager import TodoManager

class TodoMCPServer:
    """MCP Server interface dla TodoManager"""
    
    def __init__(self, db_path: str = "todoit.db"):
        self.manager = TodoManager(db_path)
        self.server = Server("todoit")
        self._register_tools()
    
    def _register_tools(self):
        """Rejestruje wszystkie narzƒôdzia MCP"""
        
        @self.server.tool()
        async def todo_append_items(arguments: dict) -> dict:
            """Dodaje wiele zada≈Ñ na ko≈Ñcu listy"""
            try:
                items = self.manager.append_items(
                    list_key=arguments["list_key"],
                    items=arguments["items"]
                )
                return {
                    "success": True,
                    "added_count": len(items),
                    "items": [item.to_dict() for item in items]
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_extend_list(arguments: dict) -> dict:
            """Rozszerza listƒô o zadania z innego ≈∫r√≥d≈Ça"""
            try:
                count = self.manager.extend_list(
                    list_key=arguments["list_key"],
                    source_list_key=arguments.get("source_list_key"),
                    source_file=arguments.get("source_file"),
                    items=arguments.get("items")
                )
                return {
                    "success": True,
                    "extended_count": count
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_insert_item(arguments: dict) -> dict:
            """Wstawia zadanie w konkretne miejsce listy"""
            try:
                item = self.manager.insert_item(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    content=arguments["content"],
                    position=arguments.get("position"),
                    after_item_key=arguments.get("after_item_key"),
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_create_list(arguments: dict) -> dict:
            """Tworzy nowƒÖ listƒô TODO"""
            try:
                todo_list = self.manager.create_list(
                    key=arguments["list_key"],
                    title=arguments["title"],
                    items=arguments.get("items"),
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "list": todo_list.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_add_item(arguments: dict) -> dict:
            """Dodaje zadanie do listy"""
            try:
                item = self.manager.add_item(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    content=arguments["content"],
                    metadata=arguments.get("metadata")
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_check_item(arguments: dict) -> dict:
            """Oznacza zadanie jako wykonane/niewykonane"""
            try:
                states = arguments.get("states", {})
                status = arguments.get("status")
                
                # Automatyczne ustawienie statusu na podstawie stan√≥w
                if not status and states:
                    if all(states.values()):
                        status = "completed"
                    elif any(states.values()):
                        status = "in_progress"
                
                item = self.manager.update_item_status(
                    list_key=arguments["list_key"],
                    item_key=arguments["item_key"],
                    status=status,
                    completion_states=states
                )
                return {
                    "success": True,
                    "item": item.to_dict()
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_next(arguments: dict) -> dict:
            """Pobiera nastƒôpne zadanie do wykonania"""
            try:
                item = self.manager.get_next_pending(
                    list_key=arguments["list_key"],
                    respect_dependencies=arguments.get("respect_dependencies", True)
                )
                if item:
                    return {
                        "success": True,
                        "item": item.to_dict()
                    }
                else:
                    return {
                        "success": True,
                        "item": None,
                        "message": "Brak zada≈Ñ do wykonania"
                    }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_progress(arguments: dict) -> dict:
            """Pobiera postƒôp listy"""
            try:
                progress = self.manager.get_progress(arguments["list_key"])
                return {
                    "success": True,
                    "progress": progress
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_get_by_thread(arguments: dict) -> dict:
            """Pobiera listy powiƒÖzane z thread_id"""
            try:
                lists = self.manager.get_lists_by_relation(
                    relation_type="thread",
                    relation_key=arguments["thread_id"]
                )
                return {
                    "success": True,
                    "lists": [l.to_dict() for l in lists]
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        @self.server.tool()
        async def todo_bulk_update(arguments: dict) -> dict:
            """Aktualizuje wiele zada≈Ñ jednocze≈õnie"""
            try:
                count = self.manager.bulk_update(
                    list_key=arguments["list_key"],
                    filter_criteria=arguments.get("filter", {}),
                    updates=arguments["updates"]
                )
                return {
                    "success": True,
                    "updated_count": count
                }
            except Exception as e:
                return {"success": False, "error": str(e)}

async def main():
    """Uruchamia serwer MCP"""
    server = TodoMCPServer()
    async with stdio_server() as streams:
        await server.server.run(streams[0], streams[1])

if __name__ == "__main__":
    asyncio.run(main())
```

## üîß Kluczowe mechanizmy

### Tworzenie list - elastyczne opcje:
```python
# 1. Pusta lista
create_list(key="projekt_x")

# 2. Lista z N elementami (automatyczna numeracja)
create_list(key="tasks", template="Task nr", count=10)
# Tworzy: "Task nr 1", "Task nr 2", ..., "Task nr 10"

# 3. Lista na podstawie folderu
create_list(key="deploy", template="Deploy ", directory="/configs/")
# Tworzy zadania dla ka≈ºdego pliku w folderze

# 4. Import z markdown (automatyczne powiƒÖzania)
import_from_markdown("tasks.md")
# [x] [ ] Task 1 ‚Üí tworzy 2 powiƒÖzane listy
# gdzie lista2[N] wymaga lista1[N] = completed
```

### Identyfikacja list:
- Ka≈ºda lista ma unikalne **ID** (liczba) i unikalny **key** (string)
- Mo≈ºna u≈ºywaƒá obu: `get_list("42")` lub `get_list("projekt_x")`

### PowiƒÖzania i zale≈ºno≈õci:
- Import multi-column automatycznie tworzy powiƒÖzane listy
- Lista L2 powiƒÖzana z L1 blokuje zadania N w L2 dop√≥ki L1[N] != completed
- Nie mo≈ºna usunƒÖƒá listy L1 je≈õli istnieje powiƒÖzana L2

## üí° Kluczowe funkcjonalno≈õci

### 1. Multi-state completion
Dla z≈Ço≈ºonych zada≈Ñ z wieloma etapami:
```python
completion_states = {
    "designed": True,
    "implemented": True,
    "tested": False,
    "deployed": False
}
```

### 2. Hierarchiczne listy
- Listy mogƒÖ mieƒá pod-listy (parent_list_id)
- Zadania mogƒÖ mieƒá pod-zadania (parent_item_id)
- Automatyczne propagowanie status√≥w w g√≥rƒô hierarchii

### 3. Relacje miƒôdzy listami
- Po project_id dla zada≈Ñ projektu
- Po sprint_id dla zada≈Ñ sprintu
- Po tag dla grupowania tematycznego

### 4. Smart queries przez Programmatic API
```python
# Pobierz pierwsze niezrobione zadanie z uwzglƒôdnieniem zale≈ºno≈õci
next_item = manager.get_next_pending("project_alpha", respect_dependencies=True)

# Pobierz wszystkie listy dla projektu
project_lists = manager.get_lists_by_relation("project", "alpha")
```

## üöÄ Przyk≈Çady u≈ºycia

### 1. Projekt development:
```python
# Tworzenie listy
todo_create_list(
    list_key="project_alpha",
    title="Project Alpha - Development Tasks",
    items=["Setup repository", "Create database schema", "Implement API"],
    metadata={"project": "alpha", "team": "backend"}
)

# ≈öledzenie postƒôpu z multi-state
todo_check_item(
    list_key="project_alpha",
    item_key="api",
    states={"designed": True, "implemented": True, "tested": False}
)
```

### 2. Pipeline deployment:
```python
# Hierarchiczna lista dla procesu
todo_create_list(
    list_key="deployment_pipeline",
    title="Deployment Pipeline Q1",
    list_type="sequential",
    metadata={"environment": "production", "quarter": "Q1"}
)

# Sprawdzanie postƒôpu
progress = todo_get_progress(list_key="deployment_pipeline")
# {"total": 15, "completed": 8, "completion_percentage": 53.3}
```

### 3. Import z istniejƒÖcego markdown:
```python
# W kodzie Python (nie przez MCP)
manager = TodoManager()
manager.import_from_markdown("TODO-LIST.md", "imported_tasks")
```

### 4. Rozszerzanie list w trakcie pracy:
```python
# Dodawanie dodatkowych krok√≥w
todo_append_items(
    list_key="deployment_pipeline",
    items=[
        {"content": "Run security scan", "metadata": {"priority": "high"}},
        {"content": "Update documentation", "metadata": {"assignee": "docs-team"}}
    ]
)

# Rozszerzenie o kroki post-deployment
todo_extend_list(
    list_key="deployment_pipeline",
    items=[
        "Monitor performance metrics",
        "Collect user feedback",
        "Plan optimization round"
    ]
)

# Wstawienie krok√≥w walidacji
todo_insert_item(
    list_key="deployment_pipeline",
    item_key="validate_stage_1",
    content="Validate stage 1 completion",
    after_item_key="deploy_to_staging"
)

## üì¶ Struktura projektu

```
todoit-mcp/
‚îú‚îÄ‚îÄ core/                   # Programmatic API (core logic)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ manager.py         # TodoManager - g≈Ç√≥wna logika
‚îÇ   ‚îú‚îÄ‚îÄ models.py          # Modele danych (Pydantic)
‚îÇ   ‚îú‚îÄ‚îÄ database.py        # Warstwa dostƒôpu do DB
‚îÇ   ‚îî‚îÄ‚îÄ validators.py      # Regu≈Çy biznesowe
‚îú‚îÄ‚îÄ interfaces/            # Interfejsy dostƒôpu
‚îÇ   ‚îú‚îÄ‚îÄ mcp_server.py     # MCP Server
‚îÇ   ‚îî‚îÄ‚îÄ cli.py            # Rich CLI
‚îú‚îÄ‚îÄ config/               # Konfiguracja
‚îÇ   ‚îî‚îÄ‚îÄ cli_theme.py     # Motyw dla Rich CLI
‚îú‚îÄ‚îÄ migrations/           # Migracje DB (Alembic)
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_manager.py   # Testy core API
‚îÇ   ‚îú‚îÄ‚îÄ test_mcp.py      # Testy MCP interface
‚îÇ   ‚îî‚îÄ‚îÄ test_cli.py      # Testy CLI
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îî‚îÄ‚îÄ import_markdown.py # Migracja z markdown
‚îú‚îÄ‚îÄ todoit.db             # SQLite database
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ pyproject.toml        # Konfiguracja projektu
‚îî‚îÄ‚îÄ README.md
```

### Requirements:
```txt
# Core
sqlalchemy>=2.0
pydantic>=2.0
python-dateutil

# MCP
mcp-server-sdk>=1.0

# CLI
click>=8.1
rich>=13.0

# Development
pytest>=7.0
pytest-asyncio
alembic

# Optional
pyyaml  # dla importu/exportu
```

### Uruchomienie:
```bash
# Instalacja
pip install -r requirements.txt

# Uruchomienie serwera MCP
python -m interfaces.mcp_server

# Konfiguracja w Claude Code MCP settings:
# Nazwa: todoit
# Komenda: python -m interfaces.mcp_server

# Uruchomienie CLI
todoit --help

# Lub je≈õli nie zainstalowane globalnie
python -m interfaces.cli --help

# Tryb interaktywny
todoit interactive
```

### Przyk≈Çad wyglƒÖdu CLI z Rich:

```
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úÖ Lista utworzona ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ Tytu≈Ç: Project Alpha - Development                       ‚îÇ
‚îÇ Klucz: project_alpha                                     ‚îÇ
‚îÇ Typ: sequential                                          ‚îÇ
‚îÇ Zada≈Ñ: 8                                                 ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üìã Project Alpha - Development ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ # ‚îÇ Klucz      ‚îÇ Zadanie           ‚îÇ Status  ‚îÇ Stany    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1 ‚îÇ setup_db   ‚îÇ Setup database    ‚îÇ done    ‚îÇ ‚úÖtest   ‚îÇ
‚îÇ 2 ‚îÇ api_design ‚îÇ Design API        ‚îÇ done    ‚îÇ ‚úÖreview ‚îÇ
‚îÇ 3 ‚îÇ api_impl   ‚îÇ Implement API     ‚îÇ working ‚îÇ ‚úÖcode   ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ                   ‚îÇ         ‚îÇ ‚ùåtest   ‚îÇ
‚îÇ 4 ‚îÇ frontend   ‚îÇ Create frontend   ‚îÇ pending ‚îÇ          ‚îÇ
‚îÇ 5 ‚îÇ testing    ‚îÇ Integration tests ‚îÇ pending ‚îÇ          ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

Postƒôp: 40.0% (2/5)

[green]‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà[/][yellow]‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà[/][dim]‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà[/]
```

## üîê Rozszerzalno≈õƒá na przysz≈Ço≈õƒá

Dziƒôki Programmatic API, ≈Çatwo dodaƒá w przysz≈Ço≈õci:

### Web UI (gdy bƒôdzie potrzebne):
```python
# Streamlit, Gradio, lub w≈Çasny frontend
# Wszystko u≈ºywa tego samego TodoManager!
```

### pyproject.toml dla instalacji CLI:
```toml
[project]
name = "todoit-mcp"
version = "1.0.0"
description = "TODOIT - Inteligentny system zarzƒÖdzania TODO"

[project.scripts]
todoit = "interfaces.cli:cli"

[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"
```

### Instalacja jako narzƒôdzie:
```bash
# Instalacja w trybie edytowalnym (development)
pip install -e .

# Teraz mo≈ºna u≈ºywaƒá globalnie
todoit --help
todoit list all
todoit interactive
```

## üéØ Korzy≈õci tego podej≈õcia

1. **Prostota**: Brak zbƒôdnych warstw HTTP  
2. **Szybko≈õƒá**: Bezpo≈õredni dostƒôp do SQLite
3. **Modularno≈õƒá**: Programmatic API jako core
4. **Testowalno≈õƒá**: ≈Åatwe testy jednostkowe core API + testowanie przez CLI
5. **Rozszerzalno≈õƒá**: ≈Åatwo dodaƒá nowe interfejsy w przysz≈Ço≈õci
6. **Integracja**: Natywne wsparcie MCP dla Claude
7. **Developer Experience**: Rich CLI dla wygodnego testowania i debugowania
8. **Wizualizacja**: Czytelne tabele, drzewa i progress bary dziƒôki Rich

Ten design zapewnia prostotƒô poczƒÖtkowƒÖ z mo≈ºliwo≈õciƒÖ ≈Çatwego rozszerzania w przysz≈Ço≈õci!